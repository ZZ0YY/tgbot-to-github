// /worker/index.js (Final Forensic Version)

// è¿™æ˜¯ä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•°ï¼Œç”¨äºå‘é€è°ƒè¯•ä¿¡æ¯
async function sendDebugMessage(env, text) {
  const botToken = env.TELEGRAM_BOT_TOKEN;
  const adminId = env.ADMIN_USER_ID;
  if (!botToken || !adminId) return;

  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
  // å°†é•¿æ¶ˆæ¯åˆ†æ®µå‘é€ï¼Œä»¥é˜²è¶…å‡º Telegram æ¶ˆæ¯é•¿åº¦é™åˆ¶
  const MAX_LENGTH = 4096;
  const chunks = [];
  for (let i = 0; i < text.length; i += MAX_LENGTH) {
    chunks.push(text.substring(i, i + MAX_LENGTH));
  }

  for (const chunk of chunks) {
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: adminId, text: chunk })
    });
  }
}

export default {
  async fetch(request, env, ctx) {
    if (request.method !== 'POST') {
      return new Response('Method Not Allowed', { status: 405 });
    }

    try {
      const update = await request.json();
      const message = update.message || update.channel_post;

      if (message && message.chat) {
        // --- æ ¸å¿ƒçš„ã€æ³•è¯çº§çš„è¯Šæ–­é€»è¾‘ ---
        const receivedChatId = message.chat.id;
        const envChatId = env.AUTHORIZED_CHAT_ID;
        const parsedChatId = parseInt(env.AUTHORIZED_CHAT_ID, 10);
        const comparisonResult = receivedChatId === parsedChatId;

        // æ„å»ºä¸€ä»½è¯¦ç»†çš„è¯Šæ–­æŠ¥å‘Š
        const report = `
ğŸ **æ³•è¯è¯Šæ–­æŠ¥å‘Š** ğŸ

--- æ¥æ”¶åˆ°çš„æ•°æ® ---
Chat ID (å€¼): \`${receivedChatId}\`
Chat ID (ç±»å‹): \`${typeof receivedChatId}\`

--- ä»ç¯å¢ƒå˜é‡è¯»å–çš„æ•°æ® ---
env.AUTHORIZED_CHAT_ID (å€¼): \`"${envChatId}"\`
env.AUTHORIZED_CHAT_ID (ç±»å‹): \`${typeof envChatId}\`

--- è§£æåçš„æ•°æ® ---
Parsed Chat ID (å€¼): \`${parsedChatId}\`
Parsed Chat ID (ç±»å‹): \`${typeof parsedChatId}\`

--- æœ€ç»ˆæ¯”è¾ƒ ---
æ¯”è¾ƒ: \`${receivedChatId} === ${parsedChatId}\`
ç»“æœ: **${comparisonResult.toString().toUpperCase()}**

--- åŸå§‹æ¶ˆæ¯ (éƒ¨åˆ†) ---
\`\`\`json
${JSON.stringify(message, null, 2).substring(0, 1000)}
\`\`\`
        `;
        
        // å°†è¿™ä»½å®Œæ•´çš„æŠ¥å‘Šå‘é€ç»™æ‚¨
        await sendDebugMessage(env, report);
        // ------------------------------------

        // æ‰§è¡ŒåŸå§‹çš„åˆ¤æ–­é€»è¾‘
        if (comparisonResult && (message.document || message.photo || message.video || message.audio)) {
          
          const message_id = message.message_id;
          const dispatchUrl = `https://api.github.com/repos/${env.GH_REPO}/dispatches`;
          
          await fetch(dispatchUrl, {
            method: 'POST',
            headers: { 'Authorization': `token ${env.GH_PAT}`, 'Accept': 'application/vnd.github.v3+json', 'User-Agent': 'Cloudflare-Worker-Pinger' },
            body: JSON.stringify({ event_type: 'new_file_ping', client_payload: { chat_id: receivedChatId, message_id } })
          });
          
          return new Response('Ping sent', { status: 200 });
        }
      }
      return new Response('Message not applicable', { status: 200 });
    } catch (error) {
      await sendDebugMessage(env, `Worker æ‰§è¡Œæ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯:\n\`\`\`\n${error.stack}\n\`\`\``);
      return new Response('Internal Server Error', { status: 500 });
    }
  }
};